() process_transfer(sender, reciever, amount, body, sender_query_id) impure inline_ref {
  var (token_data, custom_data) = load_data();
  var [balances, pending_queries, total_supply] = token_data;

  int addr_new? = balances~transfer(sender, reciever, amount);
  int fee = addr_new? ? settings::new_addr_fee() : 0;

  int query_id = cur_lt();

  var query = pack_transfer_query(sender, reciever, amount, sender_query_id, now());
  pending_queries~udict_set_builder(64, query_id, query);
  fee += settings::query_storage_fee();

  var msg = begin_message(0x18, reciever, 0)
    .store_uint(op::recv_transfer(), 32)
    .store_uint(query_id, 64)
    .store_slice(sender)
    .store_extra(amount)
    .store_slice(body);

  raw_reserve(fee, 4); ;; debit fee
  send_raw_message(msg.end_cell(), 128); ;; forward funds

  token_data = [balances, pending_queries, total_supply];
  save_data(token_data, custom_data);
}

() process_transfer_confirmation(sender, query_id, success?, extra_change, body) impure inline_ref {
  var (token_data, custom_data) = load_data();
  var [balances, pending_queries, total_supply] = token_data;

  (slice cs, _) = pending_queries~udict_delete_get?(64, query_id);
  var (q_sender, q_reciever, amount,
       sender_query_id, utime_since) = unpack_transfer_query(cs);
  throw_unless(32, slice_data_equal?(sender, q_reciever));

  int ans_tag = resp::transfer_ok();
  ifnot (success?) {
    ;; rollback
    extra_change = amount;
    body = empty_slice();
    ans_tag = resp::transfer_fail();
  }

  if (extra_change > 0) {
    balances~transfer(q_reciever, q_sender, extra_change);
    ;; no need to collect storage fee
    ;; because fee for storing q_sender was already collected at least once
  }

  int time_passed = now() - utime_since;
  int collected_fee = settings::query_storage_fee();
  int returned_fee = collected_fee - collected_fee * time_passed / settings::storage_time();
  ;; returned_fee > 0 as long as now() - utime_since < 86 years
  var msg = begin_message(0x18, q_sender, returned_fee)
    .store_uint(ans_tag, 32)
    .store_uint(sender_query_id, 64)
    .store_slice(q_reciever)
    .store_extra(extra_change)
    .store_slice(body);

  send_raw_message(msg.end_cell(), 64); ;; forward change

  token_data = [balances, pending_queries, total_supply];
  save_data(token_data, custom_data);
}

() process_rollback(sender, query_id) impure inline {
  process_transfer_confirmation(sender, query_id, false, null(), null());
}

() recv_internal(cell in_msg_cell, slice in_msg) impure {
  var cs = in_msg_cell.begin_parse();
  var flags = cs~load_uint(4);
  var sender = ensure_simple_addr(cs~load_msg_addr());

  int op = in_msg~load_uint(32);
  if (op == 0xffffffff) {
    int query_id = in_msg~load_uint(64);
    int orig_op = in_msg~load_uint(32);
    if (flags & 1) {
      ;; in bounced messages they follow in opposite order
      (query_id, orig_op)~swap();
    }
    if (orig_op == op::recv_transfer()) {
      process_rollback(sender, query_id);
    }
    return ();
  }
  int query_id = in_msg~load_uint(64);

  if (op == op::transfer()) {
    var reciever = ensure_simple_addr(in_msg~load_msg_addr());
    int amount = in_msg~load_extra();
    slice body = in_msg;

    return process_transfer(sender, reciever, amount, body, query_id);
  }

  if (op == resp::confirm_transfer()) {
    ;; forward change to sender
    int extra_change = in_msg~load_extra();
    slice body = in_msg;
    return process_transfer_confirmation(sender, query_id, true, extra_change, body);
  }

  ifnot (op >> 31) {
    ;; unknown query, return error
    return send_message_back(sender, 0xffffffff, query_id, op, 0, 64);
  }
  ;; unknown answer, ignore
  return ();
}
